<!DOCTYPE html>
<html>
<head>
  <title>Math Defense: Strategic Operations</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .game-container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }

    .battlefield {
      position: relative;
      width: 400px;
      height: 400px;
      background-color: #2a2a2a;
      border: 2px solid #3a3a3a;
      overflow: hidden;
    }

    .grid-lines {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .grid-line {
      position: absolute;
      background-color: #3a3a3a;
    }

    .vertical {
      width: 1px;
      height: 100%;
    }

    .horizontal {
      width: 100%;
      height: 1px;
    }

    .coordinates {
      position: absolute;
      color: #666;
      font-size: 12px;
    }

    .enemy {
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: #ff4444;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
    }

    .explosion {
      position: absolute;
      width: 30px;
      height: 30px;
      background-color: #ffaa00;
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      animation: explode 0.5s ease-out forwards;
    }

    @keyframes explode {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
    }

    .controls {
      background-color: #2a2a2a;
      padding: 20px;
      border-radius: 8px;
      width: 300px;
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      color: #888;
    }

    input {
      width: 100%;
      padding: 8px;
      background-color: #333;
      border: 1px solid #444;
      color: #fff;
      border-radius: 4px;
    }

    button {
      width: 100%;
      padding: 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #0056b3;
    }

    .status {
      margin-top: 15px;
      padding: 10px;
      background-color: #333;
      border-radius: 4px;
    }

    .score {
      font-size: 18px;
      font-weight: bold;
      color: #00ff00;
      margin-bottom: 10px;
    }

    .feedback {
      color: #888;
    }
  </style>
</head>
<body>
  <h1>Cartesian Command: Artillery Training</h1>
  <div class="game-container">
    <div class="battlefield" id="battlefield">
      <div class="grid-lines" id="grid-lines"></div>
    </div>
    <div class="controls">
      <div class="score" id="score">Score: 0</div>
      <div class="control-group">
        <label for="x-coord">X Coordinate (0-10):</label>
        <input type="number" id="x-coord" min="0" max="10" step="0.1">
      </div>
      <div class="control-group">
        <label for="y-coord">Y Coordinate (0-10):</label>
        <input type="number" id="y-coord" min="0" max="10" step="0.1">
      </div>
      <button onclick="fire()">Fire Artillery</button>
      <div class="status">
        <div class="feedback" id="feedback">Enter coordinates to begin...</div>
      </div>
    </div>
  </div>

  <script>
    let score = 0;
    let enemies = [];
    const GRID_SIZE = 10;
    const BATTLEFIELD_SIZE = 400;
    const SCALE = BATTLEFIELD_SIZE / GRID_SIZE;

    // Initialize grid
    function initializeGrid() {
      const gridLines = document.getElementById('grid-lines');
      
      // Create grid lines
      for (let i = 0; i <= GRID_SIZE; i++) {
        // Vertical lines
        const vLine = document.createElement('div');
        vLine.className = 'grid-line vertical';
        vLine.style.left = `${(i / GRID_SIZE) * 100}%`;
        gridLines.appendChild(vLine);

        // Horizontal lines
        const hLine = document.createElement('div');
        hLine.className = 'grid-line horizontal';
        hLine.style.top = `${(i / GRID_SIZE) * 100}%`;
        gridLines.appendChild(hLine);

        // Add coordinates
        if (i < GRID_SIZE) {
          // X coordinates
          const xCoord = document.createElement('div');
          xCoord.className = 'coordinates';
          xCoord.textContent = i;
          xCoord.style.left = `${(i / GRID_SIZE) * 100}%`;
          xCoord.style.top = '0';
          gridLines.appendChild(xCoord);

          // Y coordinates
          const yCoord = document.createElement('div');
          yCoord.className = 'coordinates';
          yCoord.textContent = i;
          yCoord.style.left = '0';
          yCoord.style.top = `${(i / GRID_SIZE) * 100}%`;
          gridLines.appendChild(yCoord);
        }
      }
    }

    // Spawn a new enemy
    function spawnEnemy() {
      const x = Math.random() * GRID_SIZE;
      const y = Math.random() * GRID_SIZE;
      
      const enemy = document.createElement('div');
      enemy.className = 'enemy';
      enemy.style.left = `${x * SCALE}px`;
      enemy.style.top = `${y * SCALE}px`;
      
      document.getElementById('battlefield').appendChild(enemy);
      enemies.push({ element: enemy, x, y });

      // Start movement
      moveEnemy(enemy, x, y);
    }

    // Move enemy in a pattern
    function moveEnemy(enemy, startX, startY) {
      let time = 0;
      const radius = 1;
      const speed = 0.001;

      function updatePosition() {
        time += 16; // milliseconds per frame
        const x = startX + radius * Math.cos(speed * time);
        const y = startY + radius * Math.sin(speed * time);
        
        enemy.style.left = `${x * SCALE}px`;
        enemy.style.top = `${y * SCALE}px`;

        // Update enemy position in the enemies array
        const enemyObj = enemies.find(e => e.element === enemy);
        if (enemyObj) {
          enemyObj.x = x;
          enemyObj.y = y;
        }

        if (enemy.parentNode) { // Check if enemy still exists
          requestAnimationFrame(updatePosition);
        }
      }

      requestAnimationFrame(updatePosition);
    }

    // Fire artillery
    function fire() {
      const x = parseFloat(document.getElementById('x-coord').value);
      const y = parseFloat(document.getElementById('y-coord').value);
      
      if (isNaN(x) || isNaN(y) || x < 0 || x > GRID_SIZE || y < 0 || y > GRID_SIZE) {
        setFeedback('Invalid coordinates! Use values between 0 and ' + GRID_SIZE);
        return;
      }

      // Create explosion effect
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = `${x * SCALE}px`;
      explosion.style.top = `${y * SCALE}px`;
      document.getElementById('battlefield').appendChild(explosion);
      
      // Remove explosion after animation
      setTimeout(() => explosion.remove(), 500);

      // Check for hits
      let hit = false;
      enemies = enemies.filter(enemy => {
        const distance = Math.sqrt(
          Math.pow(enemy.x - x, 2) + Math.pow(enemy.y - y, 2)
        );
        
        if (distance < 0.5) { // Hit radius
          enemy.element.remove();
          score += 100;
          hit = true;
          return false;
        }
        return true;
      });

      // Update score and feedback
      document.getElementById('score').textContent = `Score: ${score}`;
      if (hit) {
        setFeedback('Direct hit! Target destroyed!');
        // Spawn new enemy after successful hit
        setTimeout(spawnEnemy, 1000);
      } else {
        setFeedback(`Miss! Shot landed at (${x.toFixed(1)}, ${y.toFixed(1)})`);
      }
    }

    function setFeedback(message) {
      document.getElementById('feedback').textContent = message;
    }

    // Initialize game
    initializeGrid();
    spawnEnemy();
    spawnEnemy();

    // Add keyboard support
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        fire();
      }
    });
  </script>
</body>
</html>
